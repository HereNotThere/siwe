"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcefileUrlMapPlugin = void 0;
const path = require("path");
const fs = require("fs");
const typedoc_1 = require("typedoc");
class SourcefileUrlMapPlugin {
    initialize(app) {
        app.options.addDeclaration({
            name: "sourcefile-url-map",
            help: "Will create URLs by prefixing the given parameter in front of each source file",
            type: typedoc_1.ParameterType.String
        });
        app.options.addDeclaration({
            name: "sourcefile-url-prefix",
            help: "Allows for advanced mappings as described in a JSON file",
            type: typedoc_1.ParameterType.String
        });
        this.subscribeToApplicationEvents(app);
    }
    subscribeToApplicationEvents(app) {
        app.converter.on(typedoc_1.Converter.EVENT_BEGIN, () => this.onBegin(app));
        app.converter.on(typedoc_1.Converter.EVENT_RESOLVE_END, (context) => this.onEndResolve(context));
    }
    onBegin(app) {
        // read options parameters
        const mapRelativePath = this.readStringOption(app, 'sourcefile-url-map');
        const urlPrefix = this.readStringOption(app, 'sourcefile-url-prefix');
        if (!mapRelativePath && !urlPrefix) {
            return;
        }
        try {
            if (mapRelativePath && urlPrefix) {
                throw new Error('use either --sourcefile-url-prefix or --sourcefile-url-map option');
            }
            if (mapRelativePath) {
                this.readMappingJson(mapRelativePath);
            }
            else if (urlPrefix) {
                this.mappings = [{
                        pattern: new RegExp('^'),
                        replace: urlPrefix
                    }];
            }
        }
        catch (e) {
            console.error('typedoc-plugin-sourcefile-url: ' + e.message);
        }
    }
    readStringOption(app, name) {
        const value = app.options.getValue(name);
        if (typeof value !== "string") {
            return undefined;
        }
        return value;
    }
    readMappingJson(mapRelativePath) {
        // load json
        const mapAbsolutePath = path.join(process.cwd(), mapRelativePath);
        let json;
        try {
            json = JSON.parse(fs.readFileSync(mapAbsolutePath, 'utf8'));
        }
        catch (e) {
            throw new Error('error reading --sourcefile-url-map json file: ' + e.message);
        }
        // validate json
        if (!(json instanceof Array)) {
            throw new Error('--sourcefile-url-map json file has to have Array as root element');
        }
        this.mappings = [];
        // validate & process json
        for (const mappingJson of json) {
            if (mappingJson instanceof Object && mappingJson.hasOwnProperty('pattern') && mappingJson.hasOwnProperty('replace') && typeof mappingJson['pattern'] === 'string' && typeof mappingJson['replace'] === 'string') {
                let regExp = null;
                try {
                    regExp = new RegExp(mappingJson['pattern']);
                }
                catch (e) {
                    throw new Error('error reading --sourcefile-url-map: ' + e.message);
                }
                this.mappings.push({
                    pattern: regExp,
                    replace: mappingJson['replace']
                });
            }
            else {
                throw new Error('--sourcefile-url-map json file syntax has to be: [{"pattern": "REGEX PATTERN STRING WITHOUT ENCLOSING SLASHES", replace: "STRING"}, ETC.]');
            }
        }
    }
    onEndResolve(context) {
        if (this.mappings === undefined) {
            throw new Error('assertion fail');
        }
        const project = context.project;
        // process mappings
        for (const sourceFile of project.files) {
            for (const mapping of this.mappings) {
                if (sourceFile.fileName.match(mapping.pattern)) {
                    sourceFile.url = sourceFile.fileName.replace(mapping.pattern, mapping.replace);
                    break;
                }
            }
        }
        // add line anchors
        for (let key in project.reflections) {
            const reflection = project.reflections[key];
            if (reflection.sources) {
                reflection.sources.forEach((source) => {
                    if (source.file && source.file.url) {
                        source.url = source.file.url + '#L' + source.line;
                    }
                });
            }
        }
    }
}
exports.SourcefileUrlMapPlugin = SourcefileUrlMapPlugin;
